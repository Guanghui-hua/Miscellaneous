# Shell编程

## 1. 基础正则表达式

正则表达式用来在文件中匹配符合条件的字符串，**正则是包含匹配**

`grep` `awk` `sed` 等命令可以支持正则表达式



通配符用来匹配符合条件的文件名，**通配符是完全匹配**

`ls` `find` `cp`这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配







## 2. 字符截取命令

### cut字段提取命令

### printf命令

### awk命令

### sed命令





## 3. 字符处理命令

### 排序命令 `sort`

语法： `sort [选项] 文件名`

选项：

`-f`  忽略大小写

`-n`  以数值型进行排序，默认使用字符型排序

`-r`  反向排序

`-t` 指定分隔符，默认分隔符是制表符

`-k n[,m]:`  按照指定的字段范围排序，从第n字段开始，m字段结束（默认到行尾）



### 统计命令 `wc`

语法： `wc [选项] 文件名`

选项：

`-l`  只统计行数

`-w`  只统计单词数

`-m`  只统计字符数



## 4. 条件判断

### 4.1 按照文件类型进行判断

| 测试选项  | 作用                                                     |
| --------- | -------------------------------------------------------- |
| `-d` 文件 | 判断该文件是否存在，并且是否为目录文件（是目录为真）     |
| `-e` 文件 | 判断该文件是否存在（存在为真）                           |
| `-f` 文件 | 判断该文件是否存在，并且是否为普通文件（是普通文件为真） |

### 两种判断格式

#### 使用test命令

一个例子 `test -e /root/install.log`  判断/root下是否有install.log

#### 使用中括号 []

`[ -e /root/install.log ]` 请注意命令两边距离中括号有空格



如何查看判断结果？ ->使用`echo $?`命令

但是这样是不是稍微显得有一些麻烦，如何解决这个问题？

`[ -d /root ] && echo "yes" || echo "no" `  第一条命令如果正确执行，则打印 yes，否则打印 no

### 4.2 按照文件权限进行判断

| 测试选项 | 作用                                           |
| -------- | ---------------------------------------------- |
| -r       | 判断文件是否存在，并且是否该文件拥有读权限     |
| -w       | 判断该文件是否存在，并且该文件是否拥有写权限   |
| -x       | 判断该文件是否存在，并且是否该文件拥有执行权限 |

### 4.3 两个文件之间进行比较

| 测试选项           | 作用                                                         |
| ------------------ | ------------------------------------------------------------ |
| ` 文件1 -nt 文件2` | 判断文件1的修改时间是否比文件2的新                           |
| `文件1 -ot 文件2`  | 判断文件1的修改时间是否比文件2的旧                           |
| `文件1 -ef 文件2`  | 判断文件1和文件2的`Inode`号是否一致，可以理解为两个文件是否为同一个文件 |

### 4.4 两个整数之间的比较

| 测试选项        | 作用                     |
| --------------- | ------------------------ |
| 整数1 -eq 整数2 | 判断整数1与整数2是否相等 |
| 整数1 -ne 整数2 | 判断两个整数是否不相等   |
| 整数1 -gt 整数2 | 整数1是否大于整数2       |
| 整数1 -lt 整数2 | 小于                     |
| 整数1 -ge 整数2 | 大于等于                 |
| 整数1 -le 整数2 | 小于等于                 |



一个例子 `[ 22 -gt 23 ] && echo yes || echo no`

表示如果22>23则返回yes否则返回no

结果是no

### 4.5 字符串的判断

| 测试选项          | 作用                                             |
| ----------------- | ------------------------------------------------ |
| -z 字符串         | 判断字符串是否为空 （为空返回为真）              |
| -n 字符串         | 判断字符串是否为非空（非空返回真）               |
| 字符串1==字符串2  | 判断字符串1是否和字符串2相等（相等返回为真）     |
| 字符串1！=字符串2 | 判断字符串2是否和字符串2不相等（不相等返回为真） |

一个例子` [ -z "$name" ] && echo yes || echo no`

如果name没有赋值，返回为yes，如果为name赋值，则返回no

### 4.6 多重条件判断

| 测试选项       | 作用                                         |
| -------------- | -------------------------------------------- |
| 判断1 -a 判断2 | 逻辑与，判断1与判断2都成立，最终结果为真     |
| 判断1 -o 判断2 | 逻辑或，判断1与判断2有一个成立，返回结果为真 |
| ! 判断         | 逻辑非                                       |

输入命令的时候 **注意空格**

```bash
aa=11
[ -n "$aa" -a "$aa" -gt 23 ] && echo yes || echo no
# -n "$aa" 判断变量aa的是否有值，同时判断变量aa是否大于23
# 因为变量aa的值不大于23，所以第一个判断为真，但是逻辑与要求均为真，所以最后返回结果为假
```



## 5. 流程控制

### 5.1 if语句

#### 1. 单分支if条件语句

```
if [ 条件判断式 ] ; then

	程序

fi
```

或者

```
if [ 条件判断 ]
	then
		程序
fi
```

注意：

+ 以if开头，以fi结尾，和其他语言不同
+ [ 条件判断式 ] 就是使用test命令判断，所以中括号和条件判断式之间必须有空格
+ then后面跟符合条件之后执行的程序，可以放在[]之后，用`;`分割，也可以换行写入，就不需要`;`

例子：判断分区使用率

```bash
#!/bin/bash

rate=$(df -h | grep "/dev/vda2" | awk '{print $5}' | cut -d "%" -f1)
# 把根分区使用率作为变量值赋予变量rate

if [ $rate -ge 80 ]
	then 
		echo "Warning! /dev/vda2 is full!!! "
fi
```

#### 2. 双分支if条件语句

```
if [ 条件判断式 ]
	then
		条件成立时，执行的程序
	else
		条件不成立时，执行的另一个程序
fi
```

#### 3. 多分支if 语句

```
if [ 条件判断式1 ]
	then
		当判断1成立时，执行程序1
	elif [ 条件判断式2 ]
		then
			当条件判断式2成立时，执行程序2
	elif ...
	else
		当所有条件都不成立，最后执行此程序
fi
```



一个例子，体会多分支语句

```bash
#!/bin/bash
#判断用户输入的是什么文件
# 通过这个脚本体会多分支语句

read -p "Please input a filename: " file
#接受键盘的输入，并赋予变量file

if [ -z "$file" ]
#判断file是否为空
	then 
		echo "Error, please input a filename"
		exit 1
elif [ ! -e "$file" ]
#判断file的值是否存在
	then 
		echo "Your input is not a file!"
		exit 2
elif [ -f "$file" ]
#判断file的值是否为普通文件
	then 
		echo "$file is a regulare file"
elif [ -d "$file" ]
#判断file的值是否为目录文件
	then 
		echo "$file is a directory"
	else
		echo "$file is an other file"
fi

```



### 5.2 case语句 多分支判断语句

case语句和`if...elif...else`语句一样都是多分支条件语句，不过和if多分支条件语句不同的是，case语句只能判断一种条件关系，而if语句可以判断多种条件关系

```
case $变量名 in
	"值1")
	如果变量的值等于值1，则执行程序1
	;;
	"值2")
	如果变量的值等于值2，则执行程序2
	;;
	*)
	如果变量的值都不是以上的值，则执行此程序
	;;
esac
```

一个例子

```bash
#!/bin/bash
#判断用户的输入

read -p "Please choose yes/no: " -t 30 cho
case $cho in 
	"yes")
		echo "Your choose is yes!"
		;;
	"no")
		echo "Your choose is no!"
		;;
	*)
		echo "Your choose is error!"
		;;
esac

```

不得不说，这语法太奇怪了...

### 5.3 for循环

#### 语法1

```
for 变量 in 值1 值2 值3...
	do
		程序
	done
```

一个例子

```bash
#!/bin/bash
#打印时间
for time in morning noon afternoon night
	do 
		echo "$time"
	done
```

还有一个例子

```bash
#!/bin/bash

cd /root/sh/
ls *.sh > ls.log

y=1
for i in $(cat ls.log)
	do
		echo $y
		y=$(( $y+1))
	done
```



#### 语法2

```
for (( 初始值;循环控制条件;变量变化 ))
	do
		程序
	done
```

一个例子

```bash
#!/bin/bash
#从1加到100

s=0
for ((i=1;i<=100;i=i+1))
do
	s=$(( $s+$i ))
done
echo "The sum of 1+2+3+...100 is: $s"
```

这里面有一个例子 ->批量添加指定数量的用户，不过有些复杂，和我的目的无关了，就不写了

### 5.4 while循环与until循环

#### while循环

while循环是不定循环，也称作条件循环，只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。这就和for的固定循环不太一样

语法

```
while [ 条件判断式 ]
	do
		程序
	done
```

一个简单的例子

```bash
#!/bin/bash

i=1
s=0
while [ $i -le 100 ]
#如果变量i的值小于等于100，则执行循环
do
		s=$(( $s+$i ))
		i=$(( $i+1 ))
done
echo "The sum is: $s"
```



#### until循环

until循环，和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序，一旦循环条件成立，则终止循环

```
until [ 条件判断式 ]
	do
		程序
	done
```

