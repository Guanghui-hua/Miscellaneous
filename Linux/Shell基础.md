#  Shell基础



## 永远的 Hello world

### 1. 输出命令 echo 

 `echo "Hello world"  `  和 ` echo 'Hello world!' `

选项： `-e` 支持反斜线控制的字符转换

​			可以通过通配符 支持16进制ASCII字符

​			还可以输出颜色   `echo -e "\e[1;31m abcd \e[0m"`

​			 `ehco -e "\e[1;颜色命令 内容 \e[0m"`

```
30m 黑色
31m 红色
32m 绿色
33m 黄色
```

写shell脚本的一个例子

```sh
#!/bin/sh
#Author: Gray

echo -e "\e[1;31m Nothing is more lamentable than a dead heart \e[0m"
```

注意第一步的注释，是有作用的，不仅是注释，而且会读取

**这个真的是血泪史啊**，我刚开始以为是 应该填绝对路径，以为是注释而已，原来它真的不是注释而已啊，应该不会有什么问题，后来发现原来真的必须写成`#!/bin/sh`不然就会出现如下错误

`-bash: ./h.sh: /home/sh: bad interpreter: No such file or directory`

这个`#!/bin/bash`表示我写的是一个shell脚本

### 2. 如何执行脚本

如果我把上面的脚本存为hello.sh，那么我如何执行这个脚本呢？

+  方法一 赋予执行权限，直接运行

  `chmod 755 hello.sh`  这样所有的用户都可以执行

  可以使用绝对路径的方式来执行 `/home/ubuntu/Luxcom/hello.sh`的方式来执行

  也可以用相对路径的方式来执行`./hello.sh`
** 一般情况下，Linux中所有的命令都必须使用绝对路径或者相对路径来执行**

+ 方法二 通过Bash调用执行脚本

  `bash hello.sh` 可以不用赋予权限
  
### 3. Windows和Linux的回车符的转换问题

通过 `-A cat 文件名`可以查看文件隐藏起来的回车符

Windows中的回车符是`M$`表示的，而Linux中的回车符是用`$`表示的，所以Linux中不能执行使用Windows编写的脚本，该如何处理这个问题

可以使用`dos2unix [Windows下的文件]`这条命令把windows下的文件的回车符转化为Linux下的回车符格式

这个命令需要安装


## 3. bash基本功能

### 3.1历史命令与命令补全

####  历史命令 history

`history [选项] [历史命令保存文件]` 

选项： `-c`  清空历史命令

​			`-w` 把缓存中的历史命令写入历史命令保存文件

历史命令默认保存1000条，这个条数可以修改

一些快捷键：

使用上、下箭头调用以前的历史命令

使用`!n`重复执行第n条历史命令

使用`!!`重复执行上一条命令

使用`!字符串`重复执行最后一条以该字符串开头的命令

####  命令与文件补全

在Bash中，命令与文件补全是非常方便与常用的功能，我们只要在输入命令或文件时，按`Tab`键会自动进行补全

如果使用第一次没有补全，再按一次，会把所有的可能情况全部显示出来

### 3.2 命令别名与常用快捷键

#### 命令别名

`alias 别名='原命令'`  	设定命令别名

`alias`      	查询命令别名

命令执行顺序：

1. 第一顺位执行用绝对路径或相对路径执行的命令
2. 第二顺位执行别名
3. 第三顺位执行Bash的内部命令
4. 第四顺位执行按照`$PATH`环境变量定义的目录查找顺序找到的第一个命令

> 其实Linux中所有的命令都是需要使用绝对路径或者相对路径才能执行的，但是系统命令之所以能够不打绝对路径，是因为在Linux中有PATH环境变量，可以使用 echo $PATH 显示环境变量，Linux使用环境变量进行了简化操作

使用命令行设置的别名只能临时生效，重启之后会失效，如何才能使别名永久生效，需要写入配置文件`.bashrc`

#### 快捷键

`ctrl + A`    强制终止当前命令

`ctrl + L`    清屏，相当于clear

`ctrl + U`    删除或者剪切光标左侧的内容

`ctrl + Y`    粘贴`ctrl + U` 或者`ctrl + K`剪切的内容

`ctrl + D`    退出当前用户

### 3.3 输入输出重定向

略

### 3.4 多命令顺序执行与管道符

| 多命令执行符 | 格式 | 作用 |
| ---- | ---- | -------------- |
| `;`          | 命令1;命令2 | 多个命令顺序执行，命令之间没有任何逻辑联系 |
| `&&`         | 命令1&&命令2 | 逻辑与   当命令1正确执行，命令2才会执行 |
| `||`         | 命令1\|\|命令2 | 逻辑或  当命令1执行不正确，命令2才会执行 |

#### * 管道符

管道符是一个非常有用的命令

命令格式： `命令1 | 命令2`

命令1的正确输出作为命令2的操作对象



可以和`grep`这个命令一起使用，可以从输出内容中搜索自己想要寻找的具体的内容

+ 介绍一下grep命令

`grep [选项] "搜索内容"  文件名`     可以搜索文件中的某些具体内容

​			`-i`  忽略大小写

​			`-n`  输出行号

​			`-v`  反向查找

​			`--color=auto`   搜索出的关键字用颜色显示 

例子： `grep "echo" hello.sh`   通过使用grep命令在hello.sh文件中寻找echo

` cat hello.sh | grep -n --color=auto "Gray" `    通过使用grep命令在输出中寻找 Gray



### 3.5 通配符和其他特殊字符

| 通配符 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| ?      | 匹配一个任意字符                                             |
| *      | 匹配0个或任意多个字符                                        |
| []     | 匹配括号中任意一个字符，例如[abc]代表一定匹配一个字符        |
| [-]    | 匹配中括号中任意一个字符，-代表一个范围，例如[a-z]代表匹配一个小写字母 |
| [^]    | 逻辑非，表示匹配不是中括号内的一个字符，例如`[^0-9]`匹配不是一个数字的字符 |

#### Bash中的其他特殊字符

| 符号                                        | 作用                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| 单引号 ''                                   | 会使特殊字符丧失作用                                         |
| 双引号  ""                                  | 有些特殊符号仍然会又作用                                     |
| 反引号\` \`                                 | 反引号括起来的内容是系统命令，在bash中会优先执行             |
| \$() 和反引号\`\`的作用一样，更推荐使用\$() |                                                              |
| ＃                                          | 注释                                                         |
| \$                                          | 用于调用变量的值，比如需要调用变量name的值时，需要用\$name的方式得到变量的值 |
| \                                           | 转义符                                                       |

## 4. Bash的变量

### shell中变量的设置规则

+ 变量名称可以由字母、数字和下划线组成，但是不能以数字开头
+ 在Bash中，**变量的默认类型都是字符串型**，如果要进行数值运算，则必须指定变量类型为数值型
+ 变量使用等号连接，等号左右两侧不能有空格
+ 如果变量的值有空格（Linux中空格代表分割)，需要使用单引号或双引号包括
+ 在变量的值中，可以使用`\`转义符
+ 如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含`$变量名`或者使用`${变量名}`
+ 如果是把命令的结果作为变量值赋予变量，则需要使用`反引号`或者`$()`包含变量
+ 建议环境变量使用大写

### 变量分类

用户自定义变量

环境变量：这种变量中主要保存的是和系统操作环境相关的数据

位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的

预定义变量：是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的

### 4.1 用户自定义变量（本地变量）

+ 变量定义   `aa=123`   **注意等号左右不能有空格**

+ 变量叠加 两种方式`aa="$aa"456`或者`aa=${aa}789`
+ 变量查看   `set`
+ 变量删除  `unset name`

可以看到这四种变量从上到下变量是越来越严格的

### 4.2 环境变量

#### 环境变量和用户自定义变量的区别

用户自定义变量  只在当前的Shell中生效，

而环境变量会**在当前Shell和这个Shell的所有子Shell当中生效**，如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的Shell中生效

环境变量和用户自定义变量的区别在于 **作用的范围不同**

#### 如何设置环境变量

`export 变量名=变量值`  声明环境变量

`env `  查询变量

`unset 变量名`  删除变量

`$变量名`  调用变量

什么是父shell ，和子shell

直接进入Linux是bash环境，如果再次输入`bash`即进入shell的子shell中，可以使用`pstree`命令来查看shell的结构，最后使用`exit`命令即可退出子shell

可以使用`set`或者`env`命令来查看系统中的变量

#### 系统常见的环境变量

##### `PATH` 是系统查找命令的路径

在ubuntu中输入`$PATH`命令，输出为

`-bash: /home/ubuntu/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games: No such file or directory`

**从这里我们也可以看出来上次得到的 在bin目录中存放的是常用的可执行文件**

在Linux系统中一切都是文件，我们输入的命令都是文件，那么为什么执行shell脚本的时候需要添加路径，而执行正常命令的时候却不要呢？

因为正常命令的路径已经存放在PATH当中去了，而Linux在执行命令时会首先在PATH中搜索，所以执行正常命令时不用添加路径

当然，我们也可以把我们的脚本存放在PATH中，这样就可以不用输入路径就可以执行，不过我们通常不会直接把这样的脚本直接添加到PATH中，因为这样可能会对原系统改动

如果想要直接运行脚本，而不用每次添加路径，更为保险的做法是**利用变量叠加**添加脚本所在路径，

`PATH="$PATH":/root` 通过这条命令，我们就把root目录存放在PATH中了，可以再次使用`$PATH`命令查看是否已经添加了`/root`目录，不过这只是临时生效，想要永远生效需要写入配置文件

##### `PS1`  定义系统提示符的命令

略

### 4.3 位置参数变量

**其实就相当于编程中的函数传递参数**

| 位置参数变量 | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| `$n`         | n为数字，`$0`代表命令本身，`$1-$9`表示接受第一个到第九个的参数，十以上的参数需要用大括号包含，如`${10}` |
| `$*`         | 这个变量代表命令行所有的参数，`$*`把所有的参数看成一个整体   |
| `$@`         | 这个变量也代表命令行中的所有参数，不过`$@`把每个参数区分对待 |
| `$#`         | 这个变量代表命令行中所有参数的个数                           |



下面是一个例子

```bash
#!/bin/bash
# 位置参数的功能

echo "A total of $# parameters"
#使用$#代表所有参数的个数
echo "The parameters is : $*"
#使用$*代表所有的参数
echo "The parameters is : $@"
#使用$@也代表所有的参数

```

`./Loca.sh 12 34 56 `

输出为

```
A total of 3 parameters
The parameters is : 12 34 56
The parameters is : 12 34 56
```



### 4.4 预定义变量

| 预定义变量 | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| `$?`       | **最后一次执行的命令（上一条命令）的返回状态**。如果这个命令的值为0，证明上一个命令正确执行，如果这个变量的值为非0（具体是哪个数，由命令自己决定），则证明上一个命令执行不正确 |
| `$$`       | 当前进程的进程号(PID)                                        |
| `$!`       | 后台运行的最后一个进程的进程号(PID)                          |

* `$?`可以判断上一条命令是否正确



### 4.5 使用`read`接受键盘输入

`read [选项] [变量名] `

选项：

`-p` 提示信息    在等待read输入时，输出提示信息

`-t ` 秒数           read可以一直等待用户输入，使用此选项可以指定等待时间

`-n` 字符数       read命令只接受指定的字符数，就会执行

`-s:`   隐藏输入的数据，



通过下面这个例子来体会

```bash
#!/bin/bash

read -t 30 -p "Please input your name: " name  #在shell脚本中，一定注意空格的使用，此处要添加空格
# -p  提示“请输入姓名”并等待30秒，把用户的输入保存入变量name中
echo "Name is $name"
echo -e "\n"

read -s -t 30 -p "Please input your age(using hidden mode): " age
# 年龄是隐私，所以我们用-s选项隐藏输入
echo "\t"
echo "Age is $age"
echo -e "\n"

read -n 1 -t 30 -p "Please select your gender[M/F]: " gender
#使用"-n 1"选项只接收一个输入字符就会执行（不用输入回车会直接执行）
echo -e "\n"
echo "Sex is $gender"
```



## 5. Bash运算符

### 5.1 数值运算与运算符

#### 方法一 declare声明变量类型

语法：`declare [+-][选项] 变量名`

选项：

​		 `-`  给变量设定类型属性

​		 `+`  取消变量的类型属性

​		`-i `  将变量声明为整数型(integer)

​		`-x` 将变量声明为环境变量

​		`-p` 显示指定变量的被声明类型

```bash
#!/bin/bash
# 数值运算

aa=11
bb=22
declare -i cc=$aa+$bb
echo $cc
```

#### 方法二 expr或let数值运算工具

```bash
#!/bin/bash
# 使用expr工具进行数值运算

aa=11
bb=22
dd=$(expr $aa + $bb)  #注意"+"左右两边有空格
echo $dd
```

#### 方法三  `$((运算式))`或者`$[运算式]`

`ff=$(($aa + $bb))`    注意在`$aa`和`$bb`两边加上空格

### 5.2 变量测试和内容替换

对于两个变量x和y，测试y的值然后对x赋值（其实可以通过if实现同样的功能）

由于那个表格过于复杂，所以就不详细记录了，形如下面两个

`x=${y-新值}` 

`x=${y:-新值}` 之类的语法，就是实现变量测试的功能

## 6. 环境变量配置文件

#### 6.1 什么是 环境变量配置文件

环境变量-配置文件

环境变量是可以在父shell和子shell都生效的变量，Linux允许把本地变量声明为环境变量，但是不会永久生效，一旦重启，就会失效

想要永久生效，需要把这个更改放进  环境变量配置文件

> 环境变量配置文件中主要是    定义  对系统的操作环境生效的  系统默认环境变量，比如PATH,HISTSIZE（历史命令保存条数）, PS1（提示符）,HOSTNAME（主机名）等默认环境变量



#### source 命令

`source 配置文件`   配置文件生效需要重启，使用`source`命令可以直接强制更改生效

`. 配置文件`   注意`.`后面有空格，`.`是`source`命令的缩写

#### 6.2 环境变量配置文件作用

系统中默认的环境变量配置文件

```
/etc/profile

/ect/profile.d/*.sh

~/.bash_profile

~/.bashrc

/etc/bashrc
```

**写在/etc目录下的文件  对所有用户生效**

**写在 ~ （家目录）下的文件只对当前用户生效**

配置文件有优先级，登录后首先读取`/ect/profile`，该文件的作用：

+ USER变量
+ LOGNAME变量
+ MAIL变量
+ PATH变量
+ HOSTNAME变量
+ HISTSIZE变量
+ umask
+ 调用`/etc/profile.d/*.sh`文件

#### 6.3 其他配置文件和登录信息

1. 注销时生效的环境变量配置文件   `~/.bash_logout`

2. 历史命令的保存文件   `~/bash_history`

3. Shell登录信息 文件

   本地登录欢迎信息文件：  `/etc/issue`

   转义符  略

   远程登录欢迎信息文件： `/etc/issue.net` 

   这个是纯文本文件，不能转义

   登陆后欢迎信息： `/etc/motd`

   不管是本地登录，还是远程登录，都可以显示欢迎信息

