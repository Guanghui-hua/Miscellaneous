# C语言文件

## 文件概念

1. 文件一般是指存储在外部介质(如磁盘)上的。

2. 操作系统是以文件为单位进行数据管理。 

## 文件的分类

1. 程序文件

   包括我们的源程序(后缀为.c)、目标文件(后缀为.obj)、可执行文件(后缀为.exe)等。这种文件的内容是程序代码。

2. 数据文件 

   文件内容不是程序，而是供我们读写的数据信息。 

   ![C语言文件](C:\Users\admin\Desktop\C语言文件.png)

计算机的存储在物理上是二进制的，所以物理上所有磁盘文件本质上是一样的，以字节为单位进行顺序存储，在逻辑上可以将磁盘文件分为二进制文件和文本文件。

## 文件指针

每个被使用的文件都会在内存中开辟一个相应的文件信息区，用来存放文件的有关信息，而这些信息被保存到一个结构体变量中。

```C
 typedef struct
{
    short level; //缓冲区"满"或者"空"的程度
    unsigned flags; //文件状态标志
    char fd; //文件描述符
    unsigned char hold; //如无缓冲区不读取字符
    short bsize; //缓冲区的大小
    unsigned char *buffer;//数据缓冲区的位置
    unsigned ar; //指针，当前的指向
    unsigned istemp; //临时文件，指示器
    short token; //用于有效性的检查
}FILE;
```

为了方便起见，我们一般不对 FILE 变量进行命名，而是使用指针的方式。

**在 C 语言中用一个指针变量指向一个文件，这个指针称为文件指针,指向文件的指针变量并不是指向外部介质数据文件的开头，而是指向内存中的文件信息（结构体FILE）的开头**

C 语言中有三个特殊的文件指针由系统默认打开，用户无需定义即可直接使用: 

`stdin`： 标准输入，默认为当前终端（键盘），我们使用的 scanf、getchar 函数默认从此终端获得数据。

`stdout`：标准输出，默认为当前终端（屏幕），我们使用的 printf、puts 函数默认输出信息到此终端。

`stderr`：标准出错，默认为当前终端（屏幕），我们使用的 perror 函数默认输出信息到此终端

```C
int main(){
    printf("111\n");
    fclose(stdout);  //关闭标准输出流
    printf("222\n");
    return 0;
}
//编译结果只输出 111
```



## 文件操作流程

1. 打开文件 `fopen()`
2. 读写文件
   + 按字符读写 `fgetc()` `fputc()`
   + 按字符串读写 `fgets()` `fputs()` 
   + 文件结尾 `feof()`
3. 关闭文件 `fclose()`

### 打开文件 -> `fopen()`

所谓打开文件就是【给文件在内存中建立相应的**文件信息区**(存放文件的相关信息)和**文件缓冲区**(用来暂时存放输入输出数据)】

在打开文件的同时，需要指定指针变量去指向该文件，这样就能建立起指针变量与文件之间的联系了，我们就可以**使用指针变量去操作文件**

打开方式 `FILE* fopen(const char* filename, const char* mode);`

打开成功`fopen()`返回文件指针，失败返回`NULL`

其中的mode是指打开文件的模式设置

| 打开模式 | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| r或rb    | 以只读方式打开一个文本文件（不创建文件，若文件不存在则报错） |
| w或wb    | 以写方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件） |
| a或ab    | 以追加方式打开文件，在末尾添加内容，若文件不存在则创建文件   |
| r+ 或rb+ | 以可读、可写的方式打开文件(不创建新文件)                     |
| w+或 wb+ | 以可读、可写的方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) |
| a+或 ab+ | 以添加方式打开文件，打开文件并在末尾更改文件,若文件不存在则创建一个文件 |

b 是二进制模式的意思，b 只是在 Windows 有效，在 Linux 用 r 和 rb 的结果是一样的。

Unix 和 Linux 下所有的文本文件行都是\n 结尾，而 Windows 所有的文本文件行都是\r\n 结尾

在 Windows 平台下，以“文本”方式打开文件，不加 b;

当读取文件的时候，系统会将所有的 "\r\n" 转换成 "\n"

当写入文件的时候，系统会将 "\n" 转换成 "\r\n" 写入

以"二进制"方式打开文件，则读\写都不会进行这样的转换

在 Unix/Linux 平台下，“文本”与“二进制”模式没有区别，"\r\n" 作为两个字符原样输入输出

### 关闭文件  -> `fclose(FILE* stream)`

所谓关闭文件撤销**文件信息区**(存放文件的相关信息)和**文件缓冲区**(用来暂时存放输入输出数据)，使文件的指针变量不在指向该文件。

任何文件在使用后应该关闭，打开的文件会占用内存资源，如果总是打开不关闭，会消耗很多内存；

一个**进程**同时打开的文件数是有限制的，超过最大同时打开文件数，再次调用` fopen()`打开文件会失败；

如果没有明确的调用 fclose 关闭打开的文件，那么程序在退出的时候，操作系统会统一关闭

使用`fclose()`关闭先前` fopen()`打开的文件。此动作让**缓冲区的数据**写入文件中，并释放系统所提供的文件资源，成功返回`0`，失败返回`-1`

## 顺序读写文件



| 函数名称                                                     | 顺序读写文件方式   | 功能                                                         | 参数                                                         | 返回值                                                       |
| ------------------------------------------------------------ | ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `int fputc(int ch, FILE * stream);`                          | 按字符写文件       | 将 ch 转换为 unsigned char 后写入 stream 指定的文件中        | ch：需要写入文件的字符；<br />stream：文件指针；             | 成功：成功写入文件的字符；<br />失败：返回-1                 |
| `int fgetc(FILE * stream);`                                  | 按字符读文件       | 从 stream 指定的文件中读取一个字符                           | stream：文件指针；                                           | 成功：返回读取到的字符<br />失败：-1                         |
| `int fputs(const char * str, FILE * stream);`                | 按字符串写文件     | 将 str 所指定的字符串写入到 stream 指定的文件中，字符串结束符 '\0' 不写入文件。 | str：字符串<br />stream：文件指针                            | 成功：0<br />失败：-1                                        |
| `char * fgets(char * str, int size, FILE * stream);`         | 按字符串读文件     | 从 stream 指定的文件内读入字符，保存到 str 所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了 size - 1 个字符为止，最后会自动加上字符 '\0' 作为字符串结束 | str：字符串<br />size：指定最大读取字符串的长度（size - 1）<br />stream：文件指针 | 成功：成功读取的字符串<br />读到文件尾或出错： NULL          |
| `int fprintf(FILE * stream, const char * format, ...);`      | 按照格式化写文件   | 根据参数 format 字符串来转换并格式化数据，然后将结果输出到 stream 指定的文件中，指定出现字符串结束符 '\0' 为止。 | stream：已经打开的文件<br />format：字符串格式，用法和 printf()一样 | 成功：实际写入文件的字符个数<br />失败：-1                   |
| `int fscanf(FILE * stream, const char * format, ...);`       | 按格式化读文件     | 从 stream 指定的文件读取字符串，并根据参数 format 字符串来转换并格式化数据 | stream：已经打开的文件<br />format：字符串格式，用法和 scanf()一样 | 成功：参数数目，成功转换的值的个数<br />失败： - 1 文件的字符个数<br />失败：-1 |
| `size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);` | 用二进制方式写文件 | 以数据块的方式给文件写入内容                                 | ptr：准备写入文件数据的地址<br />size： size_t 为 unsigned int 类型，此参数指定写入文件内容的块数据大小<br />nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb<br />stream：已经打开的文件指针 | 成功：实际成功写入文件数据的块数目，此值和 nmemb 相等<br />失败：0 |
| `size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);` | 用二进制方式读文件 | 以数据块的方式从文件中读取内容                               | ptr：存放读取出来数据的内存空间<br />size： size_t 为 unsigned int 类型，此参数指定读取文件内容的块数据大小<br />nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb<br />stream：已经打开的文件指针 | 成功：实际成功读取到内容的块数，如果此值比 nmemb 小，但大于 0，说明读到文<br />失败：0 |

>在 C 语言中，EOF 表示文件结束符(end of file)，在计算中，EOF的值通常定义为-1
>
>在 while 循环中以 EOF 作为文件结束标志，这种以 EOF 作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的 ASCII 代码值的形式存放。我们知道，ASCII 代码值的范围是 0~127，不可能出现-1，因此可以用 EOF 作为文件结束标志。
>
>当把数据以二进制形式存放到文件中时，就会有-1 值的出现，因此不能采用 EOF 作为二进制文件的结束标志。为解决这一个问题，ANSI C 提供一个 feof 函数，用来判断文件是否结束。feof 函数既可用以判断二进制文件又可用以判断文本文件。

`feof(FILE* stream)`注意事项：

1.  返回值是int类型，如果返回非零值，表示到达文件结尾，如果返回0，表示没有到达文件结尾，所以文件中常常出现的是`if(feof(fp)){break;}`，这表示如果到达文件结尾，返回0，结束循环
2. 如果没有进行读操作，直接调用该函数，永远返回False
3. 先读文件，再使用feof()才有意义
4. 使用feof()时，光标不会向后移，只有进行读操作才会

### 按字符读写文件

按字符写文件 fputc

按字符读文件 fgetc

参考`fc.c`文件

### 按字符串读写文件

按字符串写文件 fputs

按字符串读文件 fgets

参考`fs.c`文件

### 按照格式化读写文件

按照格式化写文件 fprintf

按格式化读文件 fscanf

参考`ff.c`文件

### 用二进制方式读写文件

用二进制方式写文件 fwrite

用二进制方式读文件 fread

参考`fbin.c`文件

## 随机读写文件 -> fseek() rewind() ftell()

文件随机读写就是不按常规读写文件，想从哪儿入手就从哪儿入手

| 函数名称                                            | 功能                                         | 参数                                                         | 返回值                                               |
| --------------------------------------------------- | -------------------------------------------- | ------------------------------------------------------------ | ---------------------------------------------------- |
| `int fseek(FILE *stream, long offset, int whence);` | 移动文件流（文件光标）的读写位置             | stream：已经打开的文件指针<br />offset：根据 whence 来移动的位移数（偏移量），可以是正数，也可以负数，如果正数，则相对于 whence 往右移动，如果是负数，则相对于 whence 往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸<br />whence的取值：<br />SEEK_SET：从文件开头移动 offset 个字节<br />SEEK_CUR：从当前位置移动 offset 个字节<br />SEEK_END：从文件末尾移动 offset 个字节 | 成功：0 <br />失败：-1                               |
| `rewind(FILE* stream)`                              | 把文件流（文件光标）的读写位置移动到文件开头 | stream:已经打开的文件指针                                    | 无返回值                                             |
| `ftell(FILE* stream)`                               | 获取文件流（文件光标）的读写位置             | stream：已经打开的文件指针                                   | 成功：当前文件流（文件光标）的读写位置<br />失败：-1 |

## 文件缓冲区

所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去。

如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量) 。

### **文件缓冲区的存取**

磁盘文件，一般保存在硬盘、U 盘等掉电不丢失的磁盘设备中，在需要时调入内存，在内存中对文件进行编辑处理后，保存到磁盘中。

程序与磁盘之间交互，不是立即完成，系统或程序可根据需要设置缓冲区，以提高存取效率

### **文件缓冲区的刷新**

`int fflush(FILE *stream)`

功能：更新缓冲区，让缓冲区的数据立马写到文件中

参数：`stream`是文件指针

返回值：成功返回0， 失败返回 -1


